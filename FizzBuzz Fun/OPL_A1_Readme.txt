Jacob Blumsack OPL A1 Readme File
      I found this assignment very interesting given I had only had experience with python previous to this class. Each Language had its own nuances that made them unique. One of the tasks I found most difficult was working with the interpreters for each language. However Ada was easier given I was able to produce a native executable file to run the program. I found that Rosetta Code made for a very useful resource in this assignment as it showed multiple ways to implement the fizzbuzz program for each language. I definitely noticed that Ada was the most difficult in terms of coding as there is more coding conventions to keep track of for loops. I found that each interpreter for each language varied greatly in there commands for navigation so even tasks such as loading a file in to run was complicated. It was hard to notice any differences in speeds for each language as the program is fairly rudimentary. Each language executed quickly. Each program was commented to demonstrate a level of understanding as to the approach taken in each language. A Pattern matching approach was used for the Haskell implementation. In this instance, the pattern was set as (x, y) where x was the case of mod 3 and y was the case of mod 5. Then each possible case was explored to display the proper fizzbuzz output. I actually really like the pattern matching approach as I felt it made the solution easy to see. It seemed very simple to me in terms of understanding. Prolog, Ada, and Python were each implemented with if then else statements which seemed to be a verbose solution in my opinion. Go was the only implementation to use a switch statement and have each different mod combination as a different statement. I liked the python implementation for it felt familiar given my experience with it but I think Haskell was a close second for me. The simplicity was unmatched against the other languages.
